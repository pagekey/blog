const id = "blog/2018/binary-search-tree/index.mdx";
						const collection = "post";
						const slug = "binary-search-tree";
						const body = "\n![Example of a Binary Search Tree](./1example_tree.png)\n\nDecisions, decisions... Life is all about choices! Usually there are so many ways to go. An infinite expanse of roads and pathways stretches in front of you, an endless gradient of details; as you consider them, your head starts to spin, your eyes start to droop, your mind races, your head pounds -\n\nWait a second. There's no need to stress. Since we're talking about Binary Search Trees, decisions are going to be a lot easier. A Binary Search Tree (BST) gives you two choices: left or right, less than or greater than, 0 or 1 - hence the name, **binary**.\n\n## Overview\n\nA BST is a great choice for storing data that may need to be sorted. Anything that is stored in a BST must be **comparable**, which means that the data can be compared with less than `<`, greater than `>`, and equal to `==` operators.\n\nFor flat arrays, searching for, inserting, and deleting data will loop through every single element, yielding an average efficiency of `O(n)`. With a Binary Search Tree, each step down the tree cuts the remaining nodes to search by up to half. For this reason, **search on a BST is performed in `O(log(n))` time on average**. This is a significant improvement, especially for large data sets.\n\n## Insert\n\n![Binary Search Tree: Insert method diagram](./2insert.png)\n\nIn this case, the `Node` will have most of the important code for the `insert` method. The `BST` class will essentially be a wrapper for the `Node`, hiding some of the rough edges of the internal methods to give the user a clean interface.\n\nFor the `Node`, our code will look like this:\n\n```python\nclass Node(object):\n  ...\n\tdef insert(self, d):\n\t\tif self.data == d:\n\t\t\treturn False\n\t\telif d < self.data:\n\t\t\tif self.left:\n\t\t\t\treturn self.left.insert(d)\n\t\t\telse:\n\t\t\t\tself.left = Node(d)\n\t\t\t\treturn True\n\t\telse:\n\t\t\tif self.right:\n\t\t\t\treturn self.right.insert(d)\n\t\t\telse:\n\t\t\t\tself.right = Node(d)\n\t\t\t\treturn True\n  ...\n```\n\nThe above code first checks if the data object already exists in the tree. If it does, it returns `False`, indicating that no node was inserted. Otherwise, it will go to the left or right depending on whether the data to insert is greater or smaller than the node's value. If there's nothing on the side that is chosen, a new node is created, and we return `True`. Otherwise, the method continues recursively, checking and moving left or right until the data is found or inserted in the tree.\n\nThe `BST` class will wrap this neatly, beginning the recursive call on the root node like so:\n\n```python\nclass BST(object):\n  ...\n\tdef insert(self, d):\n    '''\n    returns True if successfully inserted, false if exists\n    '''\n\t\tif self.root:\n\t\t\treturn self.root.insert(d)\n\t\telse:\n\t\t\tself.root = Node(d)\n\t\t\treturn True\n  ...\n```\n\n## Find\n\n![Binary Search Tree: Find method diagram](./3find.png)\n\n`find` is another recursive method, which means that it will be implemented in the `Node` class.\n\n```python\nclass Node(object):\n  ...\n  def find(self, d):\n    if self.data == d:\n      return True\n    elif d < self.data and self.left:\n      return self.left.find(d)\n    elif d > self.data and self.right:\n      return self.right.find(d)\n    return False\n  ...\n```\n\nIn the above code snippet, we first check for the best case - did we find what we are looking for? If so, we are done and can tell everyone the good news by returning `True`.\n\nOtherwise, we have to check which way to go. If the data is less than the current node, we move left. Otherwise, we move right. However, to move left or right, there has to be something there. If not, we're just going to call it quits and return `False`.\n\nThe BST wrapper will shape up like this:\n\n```python\nclass BST(object):\n  ...\n  def find(self, d):\n    '''\n    Returns True if d is found in tree, false otherwise\n    '''\n    if self.root:\n      return self.root.find(d)\n    else:\n      return False\n  ...\n```\n\n## Remove\n\n![Binary Search Tree: Remove method diagram, leaf node removal](./4remove.png)\n<figcaption>Example of leaf node removale</figcaption>\n\n![Binary Search Tree: Remove method diagram, non-leaf node removal](./5remove.png)\n<figcaption>Example of non-leaf node removal</figcaption>\n\nFinally, the `BST` class is getting its chance to be more than just a wrapper! The `Node` class will have no `remove` method at all - the magic will happen entirely within the `BST` class.\n\nWhile most of these methods can be explained in a fairly straightforward way, `remove` is where I draw the line. For some reason, this code is ridiculously complicated, and it's best to just bite the bullet and break it down into a set of well-defined cases.\n\n```python\nclass BST(object):\n  ...\n  def remove(self, d):\n    '''\n    Returns True if node successfully removed, False if not removed\n    '''\n    # Case 1: Empty Tree?\n    if self.root == None:\n      return False\n\n    # Case 2: Deleting root node\n    if self.root.data == d:\n      # Case 2.1: Root node has no children\n      if self.root.left is None and self.root.right is None:\n        self.root = None\n        return True\n      # Case 2.2: Root node has left child\n      elif self.root.left and self.root.right is None:\n        self.root = self.root.left\n        return True\n      # Case 2.3: Root node has right child\n      elif self.root.left is None and self.root.right:\n        self.root = self.root.right\n        return True\n      # Case 2.4: Root node has two children\n      else:\n        moveNode = self.root.right\n        moveNodeParent = None\n        while moveNode.left:\n          moveNodeParent = moveNode\n          moveNode = moveNode.left\n        self.root.data = moveNode.data\n        if moveNode.data < moveNodeParent.data:\n          moveNodeParent.left = None\n        else:\n          moveNodeParent.right = None\n        return True\t\t\n    # Find node to remove\n    parent = None\n    node = self.root\n    while node and node.data != d:\n      parent = node\n      if d < node.data:\n        node = node.left\n      elif d > node.data:\n        node = node.right\n    # Case 3: Node not found\n    if node == None or node.data != d:\n      return False\n    # Case 4: Node has no children\n    elif node.left is None and node.right is None:\n      if d < parent.data:\n        parent.left = None\n      else:\n        parent.right = None\n      return True\n    # Case 5: Node has left child only\n    elif node.left and node.right is None:\n      if d < parent.data:\n        parent.left = node.left\n      else:\n        parent.right = node.left\n      return True\n    # Case 6: Node has right child only\n    elif node.left is None and node.right:\n      if d < parent.data:\n        parent.left = node.right\n      else:\n        parent.right = node.right\n      return True\n    # Case 7: Node has left and right child\n    else:\n      moveNodeParent = node\n      moveNode = node.right\n      while moveNode.left:\n        moveNodeParent = moveNode\n        moveNode = moveNode.left\n      node.data = moveNode.data\n      if moveNode.right:\n        if moveNode.data < moveNodeParent.data:\n          moveNodeParent.left = moveNode.right\n        else:\n          moveNodeParent.right = moveNode.right\n      else:\n        if moveNode.data < moveNodeParent.data:\n          moveNodeParent.left = None\n        else:\n          moveNodeParent.right = None\n      return True\n  ...\n```\n\nWhew! Glad that one's done.\n\n## Traversals\n\nThere are three ways to traverse a tree: pre-order traversal, in-order traversal, and post-order traversal. The traversals are mostly implemented in the `Node` class.\n\nWe mentioned at the start of the article that BSTs can be useful for sorting data. As it turns out, the way in which you **traverse** the tree structure will yield different element orderings that can be applied to a variety of applications.\n\nThe most straightforward example is sorting from least to greatest. If your BST contains all numbers, **an in-order traversal of the tree will return a list of all the numbers in the tree, sorted.** Another application is the conversion of expressions between infix, prefix, and postfix. If you can represent an expression as an Abstract Syntax Tree (AST) or something similar, these conversions can be performed with an in-order, pre-order, or post-order traversal of the tree.\n\nThe code for each method of traversal will look very similar. Each time, we'll simply change where we make our recursive call.\n\n### Pre-Order Traversal\n\n![Binary Search Tree: Pre-Order Traversal](./6pre_order.png)\n\n```python\nclass Node(object):\n    ...\n    def preorder(self, l):\n      '''\n      l: the list of data objects so far in the traversal\n      '''\n      l.append(self.data)\n      if self.left:\n          self.left.preorder(l)\n      if self.right:\n          self.right.preorder(l)\n      return l\n    ...\n```\n\n### In-Order Traversal\n\n![Binary Search Tree: In-Order Traversal](./7in_order.png)\n\n```python\nclass Node(object):\n    ...\n    def inorder(self, l):\n      '''\n      l: the list of data objects so far in the traversal\n      '''\n      if self.left:\n          self.left.preorder(l)\n      l.append(self.data)\n      if self.right:\n          self.right.preorder(l)\n      return l\n    ...\n```\n\n### Post-Order Traversal\n\n![Binary Search Tree: Post-Order Traversal](./8post_order.png)\n\n```python\nclass Node(object):\n    ...\n    def postorder(self, l):\n      '''\n      l: the list of data objects so far in the traversal\n      '''\n      if self.left:\n          self.left.preorder(l)\n      if self.right:\n          self.right.preorder(l)\n      l.append(self.data)\n      return l\n    ...\n```\n\nFor each traversal, I added a corresponding wrapper in the BST class to expose it:\n\n```python\nclass BST(object):\n  def preorder(self):\n    '''\n    Returns list of data elements resulting from preorder tree traversal\n    '''\n    if self.root:\n      return self.root.preorder([])\n    else:\n      return []\n  def postorder(self):\n    '''\n    Returns list of post-order elements\n    '''\n    if self.root:\n      return self.root.postorder([])\n    else:\n      return []\n  def inorder(self):\n    '''\n    Returns list of in-order elements\n    '''\n    if self.root:\n      return self.root.inorder([])\n    else:\n      return []\n```\n\n## Full Source and Tests\n\nThank you for reading. Check out the full source code for what we did today below!\n\n**[Full BST source code](https://github.com/pagekeysolutions/education/blob/master/BST/bst.py)**\n\n**[BST test code](https://github.com/pagekeysolutions/education/blob/master/BST/test_bst.py)**\n";
						const data = {publishDate:new Date(1524096000000),title:"How to Implement a Binary Search Tree in Python",tags:["python","tutorial"]};
						const _internal = {
							type: 'content',
							filePath: "/home/runner/work/website/website/astrowind/src/content/post/blog/2018/binary-search-tree/index.mdx",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
