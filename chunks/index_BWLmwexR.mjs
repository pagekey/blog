const id = "blog/2017/linked-lists-in-python/index.mdx";
						const collection = "post";
						const slug = "blog/2017/linked-lists-in-python";
						const body = "\nNeed a quick run down on a classic data structure? Look no further.\n\n**Click [here][list-src] for the full LinkedList source code. Also, [here][list-test] is the test code.**\n\nA linked list is an ordered collection of elements. The thing that makes it special is how it stores data. Behind the scenes, each number, string, object, or other value you may need to keep track of is stored in a Node. Each Node references its successor.\n\nThe advantage to this approach is the dynamic nature of the list. Unless you run out of memory, **you can't run out of space in a linked list**, because the last Node in the list always has room to reference another Node. Conversely, when you run out of space in a flat array, you need to create a new, larger array and fill it with the data from the original, which can be inefficient.\n\nIn this case, we will be talking about a **singly linked list**, meaning that each Node only has one reference, which belongs to the **next** Node. For a __doubly linked list__, there would be an additional reference to the **previous** Node.\n\nimport BlogYoutubeVideo from '~/components/common/BlogYoutubeVideo.astro';\n\n<BlogYoutubeVideo videoId=\"KZVU2X4Dw8w\" />\n\n## Nodes and Ropes\n\nThe concept of a **Node** is central to linked lists. A linked list Node contains two important fields: `next_node` and `data`. The field `next_node` refers to another Node object, the next element in the list. The `data` field refers to whatever you are actually storing in the list, which could be anything from a name or phone number to the result of a computation.\n\nAn easy way to visualize a linked list is by picturing each Node as a box. The box has space for you to hold your `data`. It also has a hole with a rope coming out - this rope is the `next_node` reference. When you create your list and add elements, you are essentially tying each `Node`'s rope to the next one in line.\n\nPutting this idea into code will yield the following `Node` object:\n\n```python\nclass Node(object):\n\tdef __init__(self, d):\n\t\tself.next_node = None\n\t\tself.data = d\n```\n\n## List Setup - Heads and Tails\n\nUnlike a regular flat array, we can't access each list item by index. Instead, we must iterate from one of two points of reference: the `head` and the `tail` of the list, each of which contain a Node object. Think of these as the only two \"handles\" we have to grab the list by. From the `head`, we can work our way down the list by following `next_node` references unitl we reach the `tail`.\n\nKeep in mind that while the `head` and `tail` hold Node objects, they are set to `None` when the list is created. This is because the list starts out empty, so we don't have any Node objects to use for them.\n\n```python\nclass LinkedList(object):\n\tdef __init__(self):\n\t\tself.head = None\n\t\tself.tail = None\n\t\tself.size = 0\n```\n\n## Adding elements\n\nAdding an element to a list involves updating the `next_node` references of surrounding Nodes to integrate it into the list, \"tying\" all the ropes in their proper places. The simplest situation to consider is when a node is added to the end of a list. In this case, simply update `tail.next_node` to point to your new node. At this point, the new node is the last element in the list, so you should update `tail` to reflect this.\n\nNote that if the list is empty, you only need to set `head` and `tail` to your new list node. In either case, increment the list's size by one. Adding a node to the end of the list is completed in O(1) time.\n\n```python\n\t# Add d to tail of list\n\tdef add(self, d):\n\t\tnew_node = Node(d)\n\t\tif self.tail:\n\t\t\tself.tail.next_node = new_node\n\t\t\tself.tail = new_node\n\t\telse:\n\t\t\tself.head = new_node\n\t\t\tself.tail = new_node\n\t\tself.size += 1\n```\n\nAdding a node at a specific index in the list is a more complex operation. To do this, you need to iterate the list to find the `current_node` at the index you will be inserting the new data, as well as the `previous` node. Once you have these references, tie the previous node to the new node, and the new node to the rest of the list. In code, this would mean setting `previous.next_node = new_node` and `new_node.next_node = current_node`.\n\n```python\n\t# Return True if d is in list, false otherwise\n\tdef find(self, d):\n\t\tcurrent_node = self.head\n\t\twhile current_node:\n\t\t\tif current_node.data == d:\n\t\t\t\treturn True\n\t\t\tcurrent_node = current_node.next_node\n\t\treturn False\n```\n\n## Removing elements\n\nRemoving an element is fairly straightforward, though it may seem counterintuitive at first. You need two references: `previous`, the node __before__ the one you are deleting, and `node`, the one you are deleting. Once you have checked and found the `data` you need in `node`, simply set `previous.next_node = node.next_node`. This snippet of code reassigns the previous node from pointing to the node we are deleting to the node beyond it. In this way, the `node` we are deleting is not set as the `next_node` of any other node. Since nothing references it, it is as good as gone - Garbage collection will see that it gets deleted.\n\nOnce you have the `previous` and `node` references, the remove operation has a time complexity of O(1).\n\n```python\n\t# Remove d; return True if successful, false otherwise\n\tdef remove(self, d):\n\t\tprevious_node = None\n\t\tcurrent_node = self.head\n\t\twhile current_node:\n\t\t\tif current_node.data == d:\n\t\t\t\tif previous_node:\n\t\t\t\t\tprevious_node.next_node = current_node.next_node\n\t\t\t\telse:\n\t\t\t\t\tself.head = current_node.next_node\n\t\t\t\tself.size -= 1\n\t\t\t\treturn True\n\t\t\tprevious_node = current_node\n\t\t\tcurrent_node = current_node.next_node\n\t\treturn False\n```\n\n## Finding elements\n\nFinding an element in your linked list is not as simple as jumping to the index you would like to access. The only way we can interact with the list is through the `head` node, `tail` node, and the links between them. The find operation will make use of a scratch variable, `current_node`, to keep track of which element of the list we are currently interacting with. To begin the find operation, set `current_node = self.head`.\n\nNext, begin a loop. For each iteration, check if you found the data you are `find`ing. If you found it, great - return either `True`, the data, or the Node; what you return depends on how you plan to use the Linked List. If you did not find it, set `current_node = current_node.next_node`, and begin the next iteration. This assignment moves your `current_node` pointer onto the next list element, allowing you to perform your check on every item in the list.\n\nThe find operation has a time complexity of O(n).\n\n```python\n\t# Return True if d is in list, false otherwise\n\tdef find(self, d):\n\t\tcurrent_node = self.head\n\t\twhile current_node:\n\t\t\tif current_node.data == d:\n\t\t\t\treturn True\n\t\t\tcurrent_node = current_node.next_node\n\t\treturn False\n```\n\n## Testing\n\nTyping `python3` on the command prompt will bring up an interactive shell in which you can interact with your new Linked List. Just make sure that you import it. If your linked list is stored in `linked_list.py`, then simply type `from linked_list import LinkedList`. Create a new LinkedList object with something like `l = LinkedList()`.\n\nPersonally, I find it tiresome to constantly run through all the methods to make sure they work and that a small change didn't break them. For this reason, I use python's `unittest` framework to run a series of tests over and over on my list until I get it right. You can use [the tests I wrote][list-test] as a template if you want to get started with unit testing in Python. To run the tests, open a terminal and type `python3 -m unittest test_linked_list.py`. To run any files with the name prefix `test_`, type `python3 -m unittest discover` to automatically detect them.\n\n## Challenges\n\nUp for a challenge? Given our completed LinkedList code, I have two more methods for you to try implementing:\n\n`find_at(self, index):`\n\n* Return the `data` found at `index`. If there is no `Node` at `index`, return `None`\n\n`remove_at(self, index):`\n\n* **Remove** and return the `data` found at `index`. If there is no `Node` at `index`, return `None`\n\nWhen you're done, leave a comment with a link to your completed challenges and any tests that go with them!\n\n## Full Source\n\nIf you want to see all of the code for our finished LinkedList, [check out the source][list-src] on Github.\n\n[list-src]: https://github.com/pagekeysolutions/education/blob/master/LinkedList/linked_list.py\n[list-test]: https://github.com/pagekeysolutions/education/blob/master/LinkedList/test_linked_list.py\n";
						const data = {publishDate:new Date(1497916800000),title:"How to Implement a Linked List in Python",image:"/blog/2017/linked-lists-in-python.jpg",category:"Data Structures & Algorithms",tags:["python","tutorial"],author:"Steve Grice"};
						const _internal = {
							type: 'content',
							filePath: "/home/runner/work/website/website/astrowind/src/content/post/blog/2017/linked-lists-in-python/index.mdx",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
